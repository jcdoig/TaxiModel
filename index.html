<!DOCTYPE html>
<html>

<head>
  <title>Learning</title>
  
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8">

  <script src="./files/d3.v3.min.js"></script>
  
  <style type="text/css">
  @import url(./files/style.css);
  @import url(//fonts.googleapis.com/css?family=Yanone+Kaffeesatz:400,700);
  </style>

</head>

<body>

<svg xmlns:svg="http://www.w3.org/2000/svg" id="display" width="550" height="550">
  <g id="svg">
    <foreignObject xmlns="http://www.w3.org/2000/svg" height="500" width="500" y="25" x="25">
      <canvas id="canvas" xmlns="http://www.w3.org/1999/xhtml" width="500" height="500">
      
      </canvas>
    </foreignObject>
  </g>
</svg>
<script type='text/javascript'>
  var width,
    height,
    Family = {}


  personState = {
    NOT_ASSIGNED : 0,
    ASSIGNED : 1,
    IN_SERVICE : 2,
    SERVED : 3
  }

  taxiState = {
    IDLE : 0,
    ASSIGNED : 1,
    IN_SERVICE_AVAILABLE : 2,
    IN_SERVICE_ASSIGNED : 3
  }

  Taxis = []
  function Taxi(){
    Taxis.push(this)
    this.id = Taxis.indexOf(this)
    this.ox = Math.floor((Math.random()*width)+1)
    this.oy = Math.floor((Math.random()*height)+1)
    this.dx = this.ox
    this.dy = this.oy
    this.state = taxiState.IDLE // all taxis are initialized as idle, possible values are idle, assigned, inServiceAvailable, and inServiceUnavailable
    this.dropoffTime = 0
    this.passengerNow = null
    this.passengerNext = null
    this.distanceLeft = 0
  }

  numPax = 0;
  ActivePassengers = []
  ServedPassengers = []
  function Passenger(time){
    ActivePassengers.push(this)
    numPax++
    this.id = numPax
    this.ox = Math.floor((Math.random()*width)+1)
    this.oy = Math.floor((Math.random()*height)+1)
    this.taxi = null
    this.timeCreated = time
    this.waiting = 0;
    this.dx = Math.floor((Math.random()*width)+1)
    this.dy = Math.floor((Math.random()*height)+1)
    this.drop_off = function(){ // To be called after dropping the pax
      var array = ActivePassengers
      var index = array.indexOf(this)
      if (index > -1) {
       array.splice(index, 1)
       ServedPassengers.push(this)
      }
    }
  }

  // model parameters

  var networkWidth = 5 // miles
  var networkHeight = 5 // miles
  var networkSpeed = 20 // miles per hour
  var networkDemand = 300 // passengers per hour

  var stopTime = 1000*3600

  var pixelDensity = 100 // pixels per mile

  var width = networkWidth * pixelDensity
  var height = networkHeight * pixelDensity
  
  var speed = networkSpeed * pixelDensity / (3600000) // one hour has 3600 sec and each sec has 1000 miliseconds

  var lambda = networkDemand / (3600000) // in passengers per millisecond per network.

  var fleet = 50 // number of taxis


  d3.select("body").append("p").text("Simulating a network of "+networkWidth+" miles by "+networkHeight+" miles during "+(stopTime/1000)+" seconds")
  d3.select("body").append("p").text("Fleet size "+fleet+" taxis. Traveling at "+(networkSpeed)+" mph"+". Demand "+networkDemand+" passengers per hour ")
  
  function distance(passenger, taxi){
    //TODO: Change to a torus configuration
    return Math.sqrt( (passenger.ox - taxi.dx)*(passenger.ox - taxi.dx) + (passenger.oy - taxi.dy)*(passenger.oy - taxi.dy) )
  }

  function distanceTravel(taxi){
    return Math.sqrt( (taxi.dx - taxi.ox) * (taxi.dx -taxi.ox) + (taxi.dy -taxi.oy) * (taxi.dy -taxi.oy) )
  }

  function paintServiceArea(Taxi){
    //TODO: UI stuff
  }


  var fEvents = [] // future events
  var pEvents = [] // past events
  

  var AddEvent = {}
  var Action = {}
  var passengerQueue = []

  function createTaxis(){
    for (var i = 0; i < fleet; i++) {
      var taxi = new Taxi()
      Action.goIdle(taxi)
    };
  }

  function Event(time, run, description){
    this.Time = time
    this.Run = run
    this.Description = description
    return this
  }

  AddEvent.newPassenger = function(time) {
    // var delta = Math.log(1-(Math.random())/(-lambda/(width*height)))    
    var delta = Math.log(1-(Math.random()))/(-lambda)  
    //console.log(delta) 
    var pass = new Passenger()
    function run(){
      assignTaxi(pass, time) // (i) attempts to make a taxi assignment if possible (ii) drops the new passenger in the queue
      AddEvent.newPassenger(time+delta) // creates the next passenger arrival to the system 
    }

    var event = new Event(time, run, "New passenger")
    fEvents.push(event)
  }

  function assignTaxi(passenger, time){
    var availableTaxis = Taxis.filter(function(taxi){ return (taxi.state === taxiState.IDLE) || (taxi.state === taxiState.IN_SERVICE_AVAILABLE)})
    
    if (availableTaxis.length >= 1){
      availableTaxis.sort(function(a,b){
        var AtimeLeft = Math.max(a.dropoffTime - time, 0)
        var BtimeLeft = Math.max(b.dropoffTime - time, 0)
        return distance(passenger, a)/speed + AtimeLeft - distance(passenger, b)/speed - BtimeLeft
      })
      var taxi = availableTaxis[0]
      if (taxi.state === taxiState.IN_SERVICE_AVAILABLE) {
        taxi.state = taxiState.IN_SERVICE_ASSIGNED
        d3.select("body").append("p").text("Taxi " + taxi.id + " will drop off passenger " + taxi.passenger.id + " then it will pickup passenger " + passenger.id +" (@"+(time/1000).toFixed(0)+")").style("color","green")
        taxi.passengerNext = passenger 
      } else { // this means the taxi was idle
        taxi.passenger = passenger
        Action.gotoPassenger(taxi, time)
        AddEvent.pickUp(taxi, passenger, taxi.pickupTime)
      }
    } else {
      passengerQueue.push(passenger)
      d3.select("body").append("p").text("Passenger " + passenger.id + " is waiting for the next available taxi"+" (@"+(time/1000).toFixed(0)+")").style("color","red")
    }
  }

  Action.deliverPassenger = function(taxi, time) {
    d3.select("body").append("p").text("Taxi " + taxi.id + " just picked up passenger " + taxi.passenger.id  +" (@"+(time/1000).toFixed(0)+")")
    taxi.pickupTime = null
    taxi.ox = taxi.passenger.ox
    taxi.oy = taxi.passenger.oy
    taxi.dx = taxi.passenger.dx
    taxi.dy = taxi.passenger.dy

    taxi.state = taxiState.IN_SERVICE_AVAILABLE

    taxi.dropoffTime = distanceTravel(taxi) / speed + time
  }

  Action.assignAfterPickUp = function(taxi,time){
    if (passengerQueue.length > 0) { // Check if there's a passenger queue and assign if necessary
      passengerQueue.sort(function(a,b){
        return distance(a, taxi)/speed - distance(b, taxi)/speed
      })
      taxi.passengerNext = passengerQueue.shift() // Remove the assigned pax from the queue and assign it
      taxi.passengerNext.taxi = taxi
      d3.select("body").append("p").text("Taxi " + taxi.id + " just got assigned passenger "+ taxi.passengerNext.id + " right after pickup"+" (@"+(time/1000).toFixed(0)+")")
      taxi.state = taxiState.IN_SERVICE_ASSIGNED // the taxi is now IN_SERVICE_ASSIGNED
    }
  }

  AddEvent.pickUp = function(taxi, passenger, time){
    function run(){
      // Update the taxi state
      Action.deliverPassenger(taxi,time)
      // Try to, immediately after pick up, assign a passenger from the queue
      Action.assignAfterPickUp(taxi,time) 
      // This will happen in the future
      AddEvent.dropOff(taxi, passenger, taxi.dropoffTime)
    }

    var event = new Event(time, run, "Passenger pickup")
    fEvents.push(event)
  }

  Action.gotoPassenger = function(taxi, time){
    taxi.ox = taxi.dx
    taxi.oy = taxi.dy
    taxi.dx = taxi.passenger.ox
    taxi.dy = taxi.passenger.oy
    taxi.pickupTime = distanceTravel(taxi) / speed + time
    taxi.state = taxiState.ASSIGNED // remember that a taxi assigned cannot be assigned a next passenger until pickup
    d3.select("body").append("p").text("Taxi " + taxi.id + " on route to pickup passenger " + taxi.passenger.id  +" (@"+(time/1000).toFixed(0)+")").style("color","blue")
  }

  Action.goIdle = function(taxi){
    taxi.ox = taxi.dx
    taxi.oy = taxi.dy
    taxi.state = taxiState.IDLE
    d3.select("body").append("p").text("Taxi " + taxi.id + " is now idle" )
  }

  AddEvent.dropOff = function(taxi, passenger, time){
  
    // This will happen in the future
    function run(){
      taxi.dropoffTime = null
      d3.select("body").append("p").text("Taxi " + taxi.id + " just dropped off passenger "+ taxi.passenger.id  +" (@"+(time/1000).toFixed(0)+")")
      ServedPassengers.push(taxi.passenger) // move the passenger to the happy customer state
      taxi.passenger = null

      if (taxi.passengerNext != null) { // if the taxi has a passengerNext setup a pickup event
        taxi.passenger = taxi.passengerNext
        taxi.passengerNext = null

        Action.gotoPassenger(taxi, time) // remove the taxi from the current state and move it to the one where it belongs now
        
        AddEvent.pickUp(taxi, taxi.passenger, taxi.pickupTime)
      } else { 
        if (passengerQueue.length > 0) { // else check the queue and assign the closest passenger
          passengerQueue.sort(function(a,b){
            return distance(a, taxi)/speed - distance(b, taxi)/speed
          })
          taxi.passenger = passengerQueue.shift() // this removes the passenger from the queue while assigning it to the taxi
          taxi.passenger.taxi = taxi

          Action.gotoPassenger(taxi, time) // remove the taxi from the current state and move it to the one where it belongs now
          AddEvent.pickUp(taxi, taxi.passenger, taxi.pickupTime)
        } else { // else stay where you are
          Action.goIdle(taxi) // remove the taxi from the current state and move it to the one where it belongs now
        }
      }
    }

    // what happens now
    var event = new Event(time, run, "Passenger drop off")
    fEvents.push(event)
  }
  
  AddEvent.newPassenger(0)
  createTaxis()
  d3.timer(function(){
    fEvents.sort(function(a,b){return a.Time-b.Time})
    var event = fEvents.shift()
    event.Run()
    pEvents.push(event)

    var should_stop
    try {
      should_stop = (d3.min(fEvents.map(function(d){return d.Time})) > stopTime)
    } catch(err) {
      should_stop = false
    }
    if (should_stop) {console.log(new Date())}
    return should_stop
  })
</script>
</body>

</html>